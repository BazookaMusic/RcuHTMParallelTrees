
# LOG

---

## 7/9/2019

### Τι έγινε

1. Μελετήθηκε η χρήση Deque, Vector για την αποθήκευση των SafeNodes,το validation και τελικά το deallocation.
2. Λύθηκε το πρόβλημα του segfault σε περιπτώσεις δέντρων με πάρα πολλά επίπεδα (> 1000000) λόγω stack overflow στο cleanup.

Πως επιλέχθηκε το deque:

Εξετάστηκαν χρόνοι για το test TreeTraversalTest και μετρήθηκε η χρήση μνήμης με το εργαλείο massif:
DEQUE:
10000000 στοιχεία: 0m10.293s
1000000 στοιχεία: 0m0.991s
10000 στοιχεία: 0m0.031s

memory usage: 19.38MB

VECTOR:
10000000 στοιχεία:  0m11.476s
1000000 στοιχεία: 0m1.066s
10000 στοιχεία:  0m0.031s

memory usage 10000: 20.35MB

Επιλέχθηκε το deque λόγω της γρηγορότερης εκτέλεσης αλλά και της χαμηλότερης κατανάλωσης μνήμης.

---

## 8/9/2019

### Τι έγινε

1. Υλοποιήθηκε το επιλεκτικό deallocation ανάλογα με το αν στα SafeNodes πρέπει να:
    1. σβηστεί ο safe κόμβος και ο original (σωστή εισαγωγή αντιγράφου)
    2. σβηστεί ο safe κόμβος και το copy (χαμένος κόμβος αντίγραφου)
    3. σβηστούν όλα και να κρατηθεί ο original (αποτυχημένη εισαγωγή αντιγράφου)
2. Υλοποιήθηκε άπειρο stack με βάση ένα deque
3. Σβήστηκε ο copy assignment constructor του InsPoint για να μην μπορεί να
δημιουργηθεί αντίγραφο του (παράλογο)

---

