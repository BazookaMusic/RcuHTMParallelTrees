
# LOG

---

## 7/9/2019

### Τι έγινε

1. Μελετήθηκε η χρήση Deque, Vector για την αποθήκευση των SafeNodes,το validation και τελικά το deallocation.
2. Λύθηκε το πρόβλημα του segfault σε περιπτώσεις δέντρων με πάρα πολλά επίπεδα (> 1000000) λόγω stack overflow στο cleanup.

Πως επιλέχθηκε το deque:

Εξετάστηκαν χρόνοι για το test TreeTraversalTest και μετρήθηκε η χρήση μνήμης με το εργαλείο massif:
DEQUE:
10000000 στοιχεία: 0m10.293s
1000000 στοιχεία: 0m0.991s
10000 στοιχεία: 0m0.031s

memory usage: 19.38MB

VECTOR:
10000000 στοιχεία:  0m11.476s
1000000 στοιχεία: 0m1.066s
10000 στοιχεία:  0m0.031s

memory usage 10000: 20.35MB

Επιλέχθηκε το deque λόγω της γρηγορότερης εκτέλεσης αλλά και της χαμηλότερης κατανάλωσης μνήμης.

---

## 8/9/2019

### Τι έγινε

1. Υλοποιήθηκε το επιλεκτικό deallocation ανάλογα με το αν στα SafeNodes πρέπει να:
    1. σβηστεί ο safe κόμβος και ο original (σωστή εισαγωγή αντιγράφου)
    2. σβηστεί ο safe κόμβος και το copy (χαμένος κόμβος αντίγραφου)
    3. σβηστούν όλα και να κρατηθεί ο original (αποτυχημένη εισαγωγή αντιγράφου)
2. Υλοποιήθηκε άπειρο stack με βάση ένα deque
3. Σβήστηκε ο copy assignment constructor του ConnPoint για να μην μπορεί να
δημιουργηθεί αντίγραφο του (παράλογο)

---

## 31/9/2019

### Τι έγινε

1. Υλοποιήθηκε το validation με τρόπο που βεβαιώνονται τα εξής:
    1. Κάθε αντιγραμμένου κόμβου τα παιδιά δεν έχουν αλλάξει σε σχέση με το copy
    2. Η ρίζα του αντιγραμμένου δέντρου είναι συνδεδεμένη ακόμα με το δέντρο


### Νέοι περιορισμοί

Τα δέντρα θα έχουν σταθερό μέγιστο πλήθος κόμβων και allocated μνήμη για όλους
αυτούς τους pointers.

---

## 01/10/2019

### Τι έγινε
Τρελές αλλαγές:

1. Άλλαξε η λογική του connection point:

    1. Το Connection Point κρατάει πια τα εξής στοιχεία:

        1. head: η ρίζα του αντιγραμμένου δέντρου,
        2. connection_point: pointer στον κόμβο του οποίου το παιδί θα αλλάξει,
        ο οποίος αν είναι null σημαίνει ότι θα αλλάξει η ρίζα του αρχικού δέντρου
        3. connection_pointer: pointer στον pointer που θα αλλάξει ατομικά για να συνδεθεί
        το δέντρο (γίνεται _root αν δεν έχω connection_point)
        4. _root, η ρίζα του αρχικού δέντρου,
        5. child_to_exchange, ο δείκτης του παιδιού του connection point που θα
        συνδεθεί το παλιό head, αν γίνει pop του path
        6. path_to_ins_point, η διαδρομή ως το connection point
        7. copy_connected, true αν ολοκληρώθηκε το connect copy

    2. Υλοποιήθηκε το path pop με τη νέα λογική και συνδυάστηκε με το validation
    3. Οι κόμβοι έχουν πια υλοποιηθεί με σταθερό μέγιστο πλήθος παιδιών, χρησιμοποιώντας compile time
    size limit μέσω constexpr.

### Νέοι περιορισμοί

Τα δέντρα θα έχουν σταθερό μέγιστο πλήθος κόμβων και allocated μνήμη για όλους
αυτούς τους pointers.

---

---

## 02/10/2019

### Τι έγινε

1. Copy connection tests
2. Αλλαγή ονόματος api των connection points

---

## 04/10/2019

### Τι έγινε

1. Validation Tests
2. Προστέθηκε το modified flag στο connPoint ώστε να
μην γίνεται τίποτα χωρίς να έχει γίνει αλλαγή στο δέντρο
3. Pop Path tests (πολύ βαρετή δουλειά)   | REFACTOR?|
4. Άλλαξαν ονόματα και έγιναν αλλαγές στις μεθόδους που ξεκινάς τη δημιουργία
ενός δέντρου-αντίγραφου
5. Μετατράπηκαν τα C arrays σε std::arrays για να καθαρίζονται πιο intuitively

---
## 06/10/2019

### Τι έγινε

1. Υλοποιήθηκε και ελέγχθηκε ενα spinlock για χρήση με TSX
2. Υλοποιήθηκε ένα scope controlled κλείδωμα με TSX στο TSXGuard

Δυσκολίες: Ήταν δύσκολο να ελεγχθούν διότι ο συγχρονισμός
δεν φαινόταν απαραίτητος προτού εισάγω πολύ δουλειά σε κάθε thread.

#### Highlights
  tsx_scope ιδέα: http://individual.utoronto.ca/mikedaiwang/tm/Intel_TSX_Overview.pdf
  _mm_pause()
  http://www.1024cores.net/home/lock-free-algorithms/tricks/spinning

---

## 07-08/10/2019

### Τι έγινε

1. Debugging στο TSXGuard και δημιουργία συστήματος user abort
2. Κανονικότατο testing

### Δυσκολίες

    1. Χωρίς alignment τα στατιστικά προκαλούσαν πολλά conflict aborts.
    2. Ο remote υπολογιστής δε με αφήνει να χρησιμοποιήσω vscode.
---
